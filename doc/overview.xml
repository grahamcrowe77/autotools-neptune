<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE chapter SYSTEM "chapter.dtd">

<chapter>
  <header>
    <copyright>
      <year>2022</year><year>2022</year>
      <holder>Graham Crowe. All Rights Reserved.</holder>
    </copyright>
    <title>Overview</title>
    <prepared>Graham Crowe</prepared>
    <responsible></responsible>
    <docno></docno>
    <approved></approved>
    <checked></checked>
    <date>2022-01-02</date>
    <rev></rev>
    <file>overview.xml</file>
  </header>
  <section>
    <title>Summary</title>
    <p>Neptune is a tool for creating Erlang skeleton code, for an Erlang
    Application or an Erlang Release. The skeleton code created includes a
    build system based upon GNU Autotools which supports portability and
    follows standard build and installing practices. Neptune creates skeleton
    code for that supports the following distinct steps when building
    software:</p>
    <pre>
      <input>$ </input>./configure &amp;&amp; make &amp;&amp; make install DESTDIR=$HOME</pre>
    <p>The configuration step is invoked by running the <c>configure</c>
    script. Its purpose is to check the build environment for build
    pre-requisites and dependencies. Errors occur if critical vital
    pre-requisites or dependencies are not detected, or warnings are emitted
    if parts of the build can not be supported, e.g. generating
    documentation or running tests. It then generates makefiles from makefile
    templates suited to the build environment.</p>
    <p>The build step is invoked by running <c>make</c> and this just runs the
    makefiles generated by <c>configure</c>. The build scope includes all
    building the application beam files an NIF as well as generating the
    documentation if the build environment supports that.</p>
    <p>The installation step is invoked by running <c>make install</c>. This
    example shows the use of <c>DESTDIR</c> which is staging directory prefix
    and in this case does not require sudo priviledges.</p>
  </section>
  <section>
    <title>Why use GNU Autotools?</title>
    <p>The short answer is to support portability of the build. There
    are many Erlang applications that include foreign code typically written
    in <c>C</c>. Erlang source code is typically portable since it runs on the
    ERTS but NIFs (Native Implemented Functions) are deployed as shared
    libraries and are thus highly dependent upon the target system, be that
    the CPU architecture or the manner in which the system handles shared
    libraries. GNU Autotools provides solutions to these problems.</p>
  </section>
  <section>
    <title>Applications and Releases</title>
    <p>An Erlang Release is a deployed sytem consisting of a number of Erlang
    Applications. An Erlang Application consists of a number of modules
    providing some functionality. An application can be passive in that it
    just provides libraries, or it can be dynamic with a hierarchy of
    supervised processes. A unit of development is typically an Erlang
    Application but in practice these vary between being extremely large and
    complex or quite small and focused.</p>
  </section>
  <section>
    <title>Build and Run Time Dependencies</title>
    <p>An Erlang Application has runtime dependencies, at least to the
    <c>erts</c> and typically to the <c>kernel</c> and <c>stdLib</c>
    applications. It has build time dependencies to the erlang compiler,
    <c>erlc</c> and possibly to some public header files provided by other
    applications. It may have other dependencies too. These dependencies can
    be declared up front in <c>configure.ac</c> which is the source for
    <c>configure</c> script, and it is this script that creates makefiles,
    from templates, that are tuned to the build environment.</p>
  </section>
</chapter>
